# 个人博客系统通用开发规范

## 概述
本规范适用于个人博客系统的全栈开发，涵盖后端（Java + Spring Boot + DDD）、前端（React + Vite）及基础设施。旨在为AI生成代码、团队协作和代码审查提供统一标准。

---

## 一、目录结构组织原则

### 1.1 总体项目结构
```
personal-portfolio/
├── backend/                    # 后端项目（Maven多模块）
│   ├── domain/                # 领域层
│   ├── application/           # 应用层
│   ├── infrastructure/        # 基础设施层
│   ├── interface/             # 用户界面层（Web控制器）
│   └── startup/               # 启动模块
├── frontend/                  # 前端项目（React + Vite）
│   ├── src/
│   │   ├── components/        # 可复用组件
│   │   ├── pages/             # 页面组件
│   │   ├── services/          # API服务层
│   │   ├── hooks/             # 自定义Hooks
│   │   └── utils/             # 工具函数
│   └── public/                # 静态资源
├── docs/                      # 项目文档
├── scripts/                   # 部署与构建脚本
└── config/                    # 配置文件（可选）
```

### 1.2 后端DDD分层规范
- **领域层（domain）**：核心业务逻辑，包含实体、值对象、领域服务、仓储接口、领域事件、工厂。
  - 禁止依赖任何外部层（应用层、基础设施层、界面层）。
- **应用层（application）**：协调领域对象完成用例，包含应用服务、命令/查询对象、DTO、应用事件。
  - 仅依赖领域层，通过依赖倒置使用基础设施。
- **基础设施层（infrastructure）**：技术实现，包含持久化实现、外部服务调用、消息队列、配置、工具类。
  - 实现领域层定义的接口（如仓储接口）。
- **界面层（interface）**：用户界面，包含Web控制器、RPC接口、DTO、异常处理器。
  - 依赖应用层，不直接访问领域层。

### 1.3 前端模块化组织
- **组件分类**：
  - `components/common`：全局通用组件（按钮、输入框等）
  - `components/layout`：布局组件（导航栏、页脚等）
  - `components/features`：业务功能组件
- **页面组织**：每个页面对应一个目录，包含主组件、子组件和样式文件。
- **服务层**：按业务模块划分，每个模块一个Service文件。
- **Hooks**：提取可复用逻辑，命名以 `use` 开头。

### 1.4 配置文件管理
- 配置文件统一放在 `resources/` 目录下。
- 区分环境：`application-dev.properties`、`application-prod.properties`。
- 敏感信息（密码、密钥）使用环境变量或配置中心，禁止硬编码。

### 1.5 资源文件组织
- 静态资源（图片、字体）放在 `frontend/public/` 或 `backend/src/main/resources/static/`。
- 国际化文件按语言分目录存放。
- 模板文件放在 `resources/templates/`。

---

## 二、代码规范

### 2.1 命名规范

#### 包名（Package）
- 全部小写，使用公司域名反写（如 `com.personal.portfolio`）。
- 分层包结构：`com.personal.portfolio.blog.domain.model`。

#### 类名（Class）
- 大驼峰（PascalCase），名词或名词短语。
- 实体类：`BlogPost`、`User`
- 接口：`BlogPostRepository`（后缀为能力，如Repository、Service）
- 抽象类：`BaseEntity`、`AbstractHandler`
- 异常类：以 `Exception` 结尾，如 `BusinessException`
- 测试类：以 `Test` 结尾，如 `BlogPostServiceTest`

#### 方法名（Method）
- 小驼峰（camelCase），动词或动词短语。
- 获取方法：`getBlogPostById()`、`findAll()`
- 布尔方法：`isPublished()`、`hasPermission()`
- 业务方法：`publish()`、`cancelOrder()`
- 工厂方法：`create()`、`fromCommand()`

#### 变量名（Variable）
- 小驼峰，有意义的名词。
- 集合类型使用复数：`blogPosts`、`users`
- 临时变量：`i`、`j`、`entry`（仅限局部作用域）
- 常量：全大写，下划线分隔，如 `MAX_RETRY_COUNT`

#### 前端特定命名
- React组件：大驼峰，与文件名一致。
- 自定义Hook：以 `use` 开头，如 `useAuth`
- CSS类名：短横线分隔（kebab-case），如 `.blog-card`
- 枚举：全大写，下划线分隔，如 `POST_STATUS.PUBLISHED`

### 2.2 类设计规范
- **单一职责**：每个类只做一件事。
- **类大小限制**：单个类不超过300行（理想200行），超过应拆分。
- **字段顺序**：
  1. 静态常量
  2. 实例变量
  3. 构造函数
  4. 公共方法
  5. 受保护方法
  6. 私有方法
- **访问修饰符**：最小化暴露，优先使用 `private`，必要时使用 `protected`，避免 `public` 字段。

### 2.3 方法设计规范
- **方法长度**：不超过30行（推荐15行以内）。
- **参数数量**：不超过4个，超过时使用对象封装（命令对象、参数对象）。
- **圈复杂度**：不超过10，过高需拆分子方法。
- **抽象级别一致**：方法内所有语句应在同一抽象级别。
- **返回值**：避免返回 `null`，使用 `Optional` 或空集合。

### 2.4 注释规范
- **类注释**：说明类职责、作者、版本。
- **方法注释**：说明功能、参数、返回值、异常。
- **复杂逻辑注释**：解释业务规则和算法。
- **TODO/FIXME**：使用 `// TODO:` 或 `// FIXME:` 标注待办事项。
- **禁止无用注释**：如 `// setter`、`// getter`。

### 2.5 格式规范
- **缩进**：2个空格（前端）、4个空格（后端Java）。
- **行宽**：不超过120字符。
- **空行**：方法之间、逻辑块之间用空行分隔。
- **花括号**：K&R风格，左括号不换行。
- **导入顺序**：IDE自动优化，分组：静态导入、第三方库、项目内部。

---

## 三、代码质量原则

### 3.1 SOLID设计原则
1. **单一职责（SRP）**：每个类/模块只做一件事。
2. **开闭原则（OCP）**：对扩展开放，对修改关闭，使用接口和抽象。
3. **里氏替换（LSP）**：子类必须能替换父类而不影响程序。
4. **接口隔离（ISP）**：接口要小而专，避免臃肿。
5. **依赖倒置（DIP）**：高层模块不依赖低层模块，二者都依赖抽象。

### 3.2 DRY原则（Don't Repeat Yourself）
- 重复代码提取为方法、类或工具函数。
- 业务规则在领域层集中定义，避免散落。
- 前端重复UI组件提取为可复用组件。

### 3.3 可读性、可维护性、可扩展性
- **可读性**：命名清晰、结构清晰、注释恰当。
- **可维护性**：模块化、低耦合、高内聚。
- **可扩展性**：预留扩展点，使用策略模式、插件架构。

### 3.4 设计模式应用指南
- **工厂模式**：复杂对象创建。
- **仓储模式**：数据访问抽象。
- **策略模式**：可替换的算法。
- **观察者模式**：事件驱动。
- **装饰器模式**：动态增强功能。
- **前端容器/展示组件模式**：分离逻辑与UI。

### 3.5 代码审查检查清单
- [ ] 类是否超过300行？
- [ ] 方法是否超过30行？
- [ ] 方法参数是否超过4个？
- [ ] 圈复杂度是否过高？
- [ ] 是否有重复代码？
- [ ] 命名是否准确表达意图？
- [ ] 注释是否必要且清晰？
- [ ] 异常处理是否得当？
- [ ] 测试是否覆盖核心逻辑？
- [ ] 是否符合DDD分层依赖规则？

---

## 四、异常处理原则

### 4.1 异常分类
- **业务异常（BusinessException）**：用户操作错误、业务规则违反，应给出友好提示。
- **系统异常（SystemException）**：系统内部错误（数据库连接失败、外部服务异常），需记录日志并告警。
- **校验异常（ValidationException）**：参数校验失败，返回详细字段错误。
- **安全异常（SecurityException）**：权限不足、认证失败。

### 4.2 异常处理最佳实践
- 早抛出，晚捕获。
- 受检异常仅用于基础设施层（如IO、SQL）。
- 领域层和应用层使用运行时异常。
- 禁止空的catch块，至少记录日志。
- 异常信息中避免敏感数据（密码、密钥）。

### 4.3 错误信息设计
- 错误码：全局唯一，便于定位。
- 错误消息：用户友好，可读性强。
- 错误详情：开发调试用，包含请求ID、时间戳。
- 多语言支持：根据客户端语言返回相应消息。

### 4.4 日志记录规范
- 使用SLF4J + Logback。
- 日志级别：
  - `ERROR`：系统异常，需立即处理。
  - `WARN`：潜在问题，需要关注。
  - `INFO`：关键业务操作。
  - `DEBUG`：调试信息，开发环境开启。
  - `TRACE`：详细跟踪。
- 日志格式：包含时间、级别、线程、类名、消息、异常栈。
- 敏感信息脱敏：手机号、邮箱、身份证号等。

### 4.5 全局异常处理机制
- 使用 `@ControllerAdvice` 或全局中间件统一处理异常。
- 返回统一格式的响应：
```json
{
  "code": "ERROR_CODE",
  "message": "错误描述",
  "data": null,
  "timestamp": "2025-12-15T15:30:00"
}
```

---

## 五、测试规范

### 5.1 测试金字塔原则
- **单元测试（70%）**：测试独立功能单元，快速执行。
- **集成测试（20%）**：测试模块间交互，涉及数据库、外部服务。
- **端到端测试（10%）**：测试完整业务流程，模拟用户操作。

### 5.2 单元测试规范
- 使用JUnit 5 + Mockito。
- 测试类命名：`被测类名 + Test`，如 `BlogPostServiceTest`。
- 测试方法命名：`should_预期结果_when_条件` 或 `given_条件_when_操作_then_结果`。
- 每个测试方法只验证一个行为。
- 使用Given-When-Then结构。
- 避免测试私有方法，通过公共方法间接测试。
- 测试覆盖率目标：行覆盖率 ≥ 80%，分支覆盖率 ≥ 70%。

### 5.3 集成测试规范
- 使用 `@SpringBootTest` 启动容器。
- 使用测试数据库（如H2）或容器化数据库（Testcontainers）。
- 每个测试类结束后清理数据。
- 测试API接口时使用 `MockMvc` 或 `TestRestTemplate`。

### 5.4 端到端测试规范
- 使用Cypress或Playwright进行前端E2E测试。
- 模拟真实用户操作：点击、输入、导航。
- 测试关键用户路径：注册、登录、发布博客、评论。
- 运行在独立测试环境，避免影响生产数据。

### 5.5 测试代码质量要求
- 测试代码与生产代码同标准，保持整洁可维护。
- 避免硬编码，使用工厂方法创建测试数据。
- 测试用例独立，不依赖执行顺序。
- 失败时提供清晰错误信息。

### 5.6 测试类型总结
| 测试类型 | 测试对象 | 工具 | 执行频率 |
|----------|----------|------|----------|
| 单元测试 | 类、方法 | JUnit, Mockito | 每次提交 |
| 集成测试 | 模块交互 | SpringBootTest, Testcontainers | 每次合并 |
| 端到端测试 | 完整业务流程 | Cypress, Playwright | 每日/发布前 |
| 性能测试 | 关键接口响应时间 | JMeter, Gatling | 每周/版本发布 |

---

## 六、DDD特定规范

### 6.1 充血模型实现规范
- 实体包含数据和行为，业务逻辑内聚在实体内部。
- 每个业务方法不超过30行，参数不超过4个。
- 保护不变式：任何状态变更都经过验证。
- 无公开setter，使用有业务意义的方法（如 `publish()`、`cancel()`）。
- 发布领域事件：重要状态变更通过事件通知其他组件。

### 6.2 聚合根设计原则
- 聚合根是聚合的入口，控制内部实体的一致性。
- 聚合边界内强一致性，边界间最终一致性。
- 暴露不可变视图：`Collections.unmodifiableList()`。
- 工厂方法创建复杂聚合。

### 6.3 值对象使用规范
- 不可变：所有字段final，构造函数设置全部属性。
- 实现 `equals()` 和 `hashCode()`，基于所有字段。
- 包含丰富的业务方法：计算、验证、格式化。
- 优先使用值对象替代基本类型（如 `Money` 替代 `BigDecimal`）。

### 6.4 领域服务与应用服务职责划分
- **领域服务**：处理跨多个实体的业务逻辑，无状态。
- **应用服务**：协调领域对象，事务管理，DTO转换，不包含业务逻辑。
- 应用服务方法不超过15行，只做编排。

### 6.5 仓储模式实现
- 仓储接口定义在领域层。
- 实现类在基础设施层。
- 仓储方法返回聚合根或值对象，而非实体。
- 使用规范命名：`save()`、`findById()`、`delete()`。

---

## 七、API设计规范

### 7.1 RESTful API设计
- 资源命名：使用名词复数，如 `/blog-posts`、`/users`。
- HTTP方法：
  - `GET`：获取资源
  - `POST`：创建资源
  - `PUT`：全量更新资源
  - `PATCH`：部分更新资源
  - `DELETE`：删除资源
- 版本管理：URL路径包含版本号，如 `/api/v1/blog-posts`。
- 过滤、排序、分页：使用查询参数，如 `?page=1&size=10&sort=createdAt,desc`。

### 7.2 请求/响应格式
- 请求体：JSON格式，使用小驼峰命名。
- 响应体：统一封装，包含状态码、消息、数据、时间戳。
- 日期时间：ISO 8601格式，如 `"2025-12-15T15:30:00"`。

### 7.3 错误码设计
- 全局错误码：4位数字，前两位表示模块，后两位表示具体错误。
- 示例：`1001`（用户模块-用户不存在）、`2001`（博客模块-标题不能为空）。
- HTTP状态码映射：业务错误返回200，错误信息在body中。

### 7.4 安全规范
- 认证：JWT令牌，有效期不宜过长。
- 授权：基于角色的访问控制（RBAC）。
- 输入校验：服务端必须校验，防止SQL注入、XSS攻击。
- 敏感接口限流、防刷。
- API文档使用OpenAPI 3.0（Swagger）。

---

## 八、数据库规范

### 8.1 表设计规范
- 表名：小写，下划线分隔，如 `blog_post`、`user_profile`。
- 字段名：小写，下划线分隔，如 `created_at`、`author_id`。
- 主键：使用BIGINT自增或雪花算法生成。
- 必备字段：`id`、`created_at`、`updated_at`、`deleted`（逻辑删除）。
- 索引：为查询条件字段建立索引，避免过多索引影响写性能。

### 8.2 数据一致性保证
- 事务范围：尽量小，避免长事务。
- 乐观锁：使用 `version` 字段防止并发更新。
- 逻辑删除：使用 `deleted` 标志位，避免物理删除。
- 外键约束：数据库层或应用层保证。

### 8.3 迁移脚本管理
- 使用Flyway或Liquibase管理数据库版本。
- 脚本命名：`V{版本号}__{描述}.sql`，如 `V1.0__create_blog_post_table.sql`。
- 回滚脚本：每个变更提供回滚脚本。

---

## 九、部署与运维规范

### 9.1 环境配置
- 环境变量管理：使用配置中心或K8s ConfigMap。
- 配置文件分离：`application-dev.yml`、`application-prod.yml`。
- 密钥管理：使用Vault或云服务密钥管理。

### 9.2 日志收集
- 日志集中收集：ELK（Elasticsearch, Logstash, Kibana）或Loki。
- 结构化日志：输出JSON格式，便于解析。
- 日志保留策略：生产环境至少保留30天。

### 9.3 监控指标
- 应用监控：Spring Boot Actuator + Prometheus + Grafana。
- 业务监控：关键业务指标（注册数、发布数、访问量）。
- 告警规则：设置错误率、响应时间、系统资源告警。

### 9.4 性能优化
- 数据库查询优化：避免N+1查询，使用连接或批量查询。
- 缓存策略：Redis缓存热点数据，设置过期时间。
- 前端性能：代码分割、懒加载、图片优化、CDN加速。

---

## 十、AI生成代码提示模板

### 10.1 实体类生成提示
```
请生成充血模型的DDD实体代码，要求：
1. 数据+行为一体：实体包含丰富的业务方法
2. 每个业务方法不超过30行代码
3. 方法参数不超过4个
4. 保护不变式：所有状态变更都经过验证
5. 使用值对象替换基本类型
6. 提供工厂方法创建实例
7. 发布领域事件
8. 暴露不可变视图的内部集合
9. 包含业务计算属性（如isOverdue()）
10. 无公开setter方法，只有有业务意义的修改方法
```

### 10.2 应用服务生成提示
```
请生成DDD应用服务代码，要求：
1. 类名以AppService结尾，如BlogPostAppService
2. 每个方法对应一个用例，不超过15行
3. 使用命令对象封装参数
4. 委托给领域对象执行业务逻辑，不在应用服务实现业务规则
5. 事务管理使用@Transactional
6. 返回统一响应对象
7. 发布应用事件
8. 异常处理使用全局异常处理器
```

### 10.3 前端组件生成提示
```
请生成React组件代码，要求：
1. 使用函数组件和Hooks
2. 组件单一职责，不超过200行
3. 使用TypeScript定义Props和State
4. 错误处理使用try-catch或错误边界
5. 加载状态使用Suspense或自定义loading状态
6. 样式使用CSS Modules或Styled Components
7. 组件可复用，通过Props配置
8. 包含必要的PropTypes或TypeScript接口
```

### 10.4 API接口生成提示
```
请生成RESTful API控制器代码，要求：
1. 使用@RestController，路径前缀/api/v1
2. 每个端点对应一个HTTP方法
3. 参数校验使用@Valid和自定义注解
4. 返回统一响应对象ApiResponse
5. 异常由全局异常处理器处理
6. 接口文档使用@Operation、@ApiResponse注解
7. 安全控制使用@PreAuthorize或自定义注解
8. 日志记录关键操作
```

---

## 附录：检查清单汇总

### 代码提交前自查清单
- [ ] 代码编译通过，无语法错误
- [ ] 单元测试通过，覆盖率达标
- [ ] 集成测试通过
- [ ] 代码符合命名规范
- [ ] 无硬编码敏感信息
- [ ] 日志记录恰当
- [ ] 异常处理完善
- [ ] 文档更新（如有必要）

### 代码审查重点清单
- [ ] 架构符合DDD分层依赖
- [ ] 业务逻辑内聚在领域层
- [ ] 无重复代码
- [ ] 性能无潜在问题
- [ ] 安全无漏洞
- [ ] 测试覆盖充分
- [ ] 代码可读性高

---

**版本历史**
- v1.0 (2025-12-15)：初始版本，基于现有DDD规范和项目实践制定。
